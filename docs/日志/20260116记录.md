恭喜你！模型类（Model）和网格类（Mesh）的完成标志着你已经解决了“点、线、面”的渲染问题。接下来的**场景类（Scene / World）**则是引擎的“大管家”，它负责管理物体的生命周期、层次结构以及渲染顺序。

一个成熟的场景类通常需要包含：**对象管理、光照管理、相机管理、以及空间索引**。

---

## 1. 场景类 (CScene) 的核心职责

你可以参考以下结构来设计你的 `CScene` 类：

### A. 对象管理 (Entity/Object Management)

场景不直接持有 `CModel` 的原始数据，而是持有**“场景对象” (SceneObject)**。

* **为什么？** 因为同一个 `CModel`（比如一棵树）可能在场景中出现 100 次。
* **实现：** 场景应该维护一个列表，存储所有在空间中具有位置、旋转、缩放的实例。

### B. 渲染流程 (Rendering Pipeline)

场景负责调用所有物体的 `Draw` 函数。

* **层级管理：** 先画不透明物体，再画透明物体（由远及近）。
* **环境设置：** 在渲染所有物体前，设置全局光照、雾效、天空盒。

### C. 空间管理 (Spatial Partitioning) —— 进阶

当场景中有成千上万个物体时，直接 `for` 循环渲染会非常卡。

* **视锥剔除 (Frustum Culling)：** 只渲染相机看得到的物体。
* **实现：** 使用八叉树 (Octree) 或 AABB 树来组织场景。

---

## 2. 建议的类结构设计

### 场景对象基类 (`CSceneNode` 或 `CEntity`)

这是场景中的最小单位。

```cpp
class CSceneNode {
public:
    std::wstring m_name;
    std::shared_ptr<CModel> m_pModel;
    Vector3 m_position;
    Vector3 m_rotation;
    Vector3 m_scale;
    
    // 获取当前节点的变换矩阵
    Matrix4 GetTransform() const; 
    void Draw(); 
};

```

### 场景类 (`CScene`)

```cpp
class CScene {
public:
    // 生命周期
    void Update(float deltaTime);
    void Render();

    // 对象操作
    void AddNode(std::shared_ptr<CSceneNode> pNode);
    void RemoveNode(const std::wstring& name);

    // 环境设置
    void SetSkybox(std::shared_ptr<CSkybox> pSkybox);
    void SetMainCamera(std::shared_ptr<CCamera> pCamera);

private:
    std::vector<std::shared_ptr<CSceneNode>> m_nodes;
    std::shared_ptr<CCamera> m_pActiveCamera;
    // 环境光、平行光等
};

```

---

## 3. 下一步你需要攻克的难点

### 1. 坐标系嵌套 (Parent-Child Hierarchy)

如果你的场景中有辆车，车上有个转动的雷达。当车移动时，雷达应该跟着走。

* 你需要引入**父子节点系统**：`WorldMatrix = ParentWorldMatrix * LocalMatrix`。

### 2. 光照系统 (Lighting)

虽然你现在能看到鸭子，但那可能只是简单的“自发光”或固定管线的默认光照。

* 在 `CScene` 中，你需要管理 **Directional Light (平行光)** 和 **Point Light (点光源)**。
* 你需要决定是使用传统的 `glLightfv`（固定管线）还是编写自己的 Light Shader。

### 3. 天空盒 (Skybox)

没有天空的场景看起来像是在虚空中。天空盒其实是一个包围相机的大立方体，使用特殊的 Cubemap 纹理。

---

## 4. 动手建议

建议你先从最简单的**“扁平场景”**开始：

1. 创建一个 `std::vector<std::shared_ptr<CModel>>`。
2. 在 `CScene::Render()` 里遍历并调用每个模型的 `Draw`。
3. 确保你可以通过场景类动态地在不同位置放置多个“黄色小鸭子”。

**你想让我帮你写一个基础的 `CScene` 类的头文件草案，还是先帮你解决多个模型实例渲染时的坐标偏移问题？**


---

# 资源制作

https://www.cnblogs.com/DQ-MINE/p/17995260

裁切工具
https://jaxry.github.io/panorama-to-cubemap/

---

## 材质 和 光照系统

没有光照时：OpenGL 默认处于“着色模式”。

如果没有开启 GL_LIGHTING，系统通常只使用顶点的颜色或纹理颜色，此时设置的 glMaterial 属性会被忽略。

开启光照后：OpenGL 的固定管线光照方程会介入。

最终像素的颜色由 光源属性（Light Source） 和 材质属性（Material） 共同计算得出。
例如：最终漫反射颜色 = 光源漫反射颜色 $\times$ 材质漫反射颜色

### 实体间交互

虽然光线不会反弹，但实体之间依然有两种主要的互动方式：

阴影 (Shadows)： 一个实体挡住了光线，导致另一个实体变暗。这在固定管线中也需要手动实现（如 Shadow Mapping 阴影贴图）。

环境映射 (Environment Mapping / Reflections)： 如果你想让一个实体（比如金球）“映射”出周围实体的样子，你会使用 立方体贴图 (Cube Map)。

原理：把周围环境画成一张 6 面的贴图，贴在球体上。

关联：你代码里的 LoadSkybox 其实就是环境映射的基础。

### 光照类型

3. “坑”在哪里？（容易被忽略的复杂点）
虽然开启简单，但以下几点如果没处理好，画面会非常奇怪：

A. 法线（Normal）的变换
这是最常见的坑。如果你的模型进行了非等比缩放（例如在 X 轴拉长了 2 倍），法线也会被拉伸，导致光照计算错误（物体会异常亮或暗）。

解决方法：你需要开启自动归一化。

C++

glEnable(GL_NORMALIZE); // 性能稍低，但保证法线永远是单位向量
B. 镜面高光与顶点密度
固定管线是基于**顶点（Vertex）**计算光照的。

如果你的模型面数很低（比如一个只有 4 个顶点的正方形），高光（Specular）可能根本显现不出来，或者闪烁得很厉害。

现代 Shader 是基于**像素（Fragment）**计算的，所以更平滑。

C. 光源坐标系
glLightfv(GL_LIGHT_POSITION, ...) 的调用时机非常关键。

如果你在 gluLookAt 之前设置，灯光固定在世界中心。

如果你在 gluLookAt 之后设置，灯光会随着相机移动（就像你头上顶着个矿灯）