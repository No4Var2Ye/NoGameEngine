你遇到的“画面缩在左下角”是一个非常经典的 OpenGL 渲染架构问题。通过分析你的 `CRenderer` 和 `CCamera` 源码，我们可以将这个错误总结为 **“渲染链条的断层”**。

以下是针对你代码逻辑的深度总结：

---

### 1. 核心矛盾：视口（Viewport）与投影（Projection）的脱节

这是最根本的原因。在 OpenGL 中，要把一个 3D 物体画到屏幕上，需要两个关键步骤协同工作：

* **`glViewport`**：告诉显卡在窗口的**哪个区域**涂色。
* **投影矩阵 (Projection Matrix)**：根据**宽高比 (Aspect Ratio)** 决定 3D 空间如何映射到 2D 平面。

**你的错误在于：**
虽然你在 `CRenderer::Reset` 里更新了视口的大小，但你没有同步更新 `CCamera` 内部持有的 `m_AspectRatio`。
结果：显卡在一个很大的区域（如 ）里，按照一个很小的比例（默认的  或初始化值）去计算物体位置，导致坐标映射发生偏移，画面看起来就缩在了原点（左下角）。

---

### 2. 状态机陷阱：被覆盖的 Reset

你曾尝试在 `Reset(800, 600)` 中写死尺寸，但发现无效。这是因为：

1. 你调用 `m_Renderer->Reset(800, 600)`。
2. 进入渲染循环，调用 `m_pMainCamera->ApplyProjectionMatrix()`。
3. **相机内部逻辑**：`ApplyProjectionMatrix` 内部调用了 `GetProjectionMatrix`，它会用相机**旧的**成员变量 `m_AspectRatio` 重新生成一个矩阵，并执行 `glLoadMatrixf`。
4. 这个操作直接覆盖了你之前在 `Reset` 里所做的一切努力。

---

### 3. Win32 窗口尺寸误区 (Client vs Window)

在 Windows 编程中，窗口大小 (`GetWindowRect`) 是包含标题栏和边框的，而 OpenGL 绘图区域 (`GetClientRect`) 则是纯黑色的绘图区。

* 如果你把窗口的总宽度传给 `glViewport`，OpenGL 会认为绘图区比实际大。
* 由于投影矩阵是基于中心对称的，而视口起点在左下角，这种尺寸不匹配会导致画面发生位移和拉伸。

---

### 4. 标志位（Dirty Flag）的无效化

你的 `CCamera` 类里设计了 `m_ProjDirty`，但你在 `ApplyProjectionMatrix` 函数中并没有判断这个标志位，而是每一帧都强制重新生成投影矩阵：

```cpp
void CCamera::ApplyProjectionMatrix() const {
    Matrix4 projMatrix;
    GetProjectionMatrix(projMatrix); // 每次都现场计算，无视了 Dirty 状态
    glLoadMatrixf(projMatrix.m);
}

```

这导致即使你在别处改了设置，如果更新逻辑没打通，相机每一帧都会“固执”地按照它初始化时的错误参数重新渲染。

---

### 5. 修复逻辑总结（正确的链条）

要彻底解决这个问题，渲染流程必须满足以下**同步链条**：

| 触发点       | 动作 1 (Renderer)        | 动作 2 (Camera)                      | 动作 3 (Engine)                 |
| ------------ | ------------------------ | ------------------------------------ | ------------------------------- |
| **窗口缩放** | `glViewport(newW, newH)` | `SetProjection(fov, newW/newH, ...)` | `camera->m_ProjDirty = TRUE`    |
| **渲染开始** | `BeginFrame()` 清除画布  | `ApplyProjectionMatrix()` 上传新矩阵 | `glLoadIdentity()` 重置模型视图 |

---

### 💡 程序员的“防坑”经验：

* **永远不要让两个类独立管理同一个属性**：如果你在 `Renderer` 里存了宽度，在 `Camera` 里存了宽高比，那么当窗口变大时，你必须同时更新它们。
* **调试利器 `glScissor**`：如果你怀疑是视口问题，用 `glScissor` 配合 `glClear` 涂一个鲜艳的颜色（如红色）。如果红色没铺满窗口，就是 `Renderer` 的尺寸算错了；如果红色铺满了但物体不对，就是 `Camera` 的投影矩阵算错了。

**你想让我帮你写一个完整的 `OnResize` 函数，把渲染器和相机的更新逻辑整合在一起吗？**